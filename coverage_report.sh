#!/usr/bin/env bash
##
## Trivial Tickets Ticketsystem
## Copyright (C) 2019 The Contributors
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
##
## Ticketsystem Trivial Tickets
##
## Matriculation numbers: 3040018, 6694964, 3478222
## Lecture:               Programmieren II, INF16B
## Lecturer:              Herr Prof. Dr. Helmut Neemann
## Institute:             Duale Hochschule Baden-WÃ¼rttemberg Mosbach
##
## ---------------
## Script to generate a coverage report
## from the tests in the packages
##
## Get more information about this script here:
## https://github.com/mortenterhart/trivial-tickets/wiki/Generating-a-Coverage-Report
##

# Script constants
script="${0##*/}"
root_dir="${0%/*}"

# Output Options
output_dir=""
output_file=""
coverage_profile="${root_dir}/coverage.txt"

# Test and Coverage Options
checks=""
coverage_mode="atomic"
coverage_format="html"
preserve_profile="false"
race="false"
verbose="false"

# printError prints an error message with an help advice
# to stdout. The message is built through concatenation
# of all arguments.
function printError() {
    printf "%s: %s\n" "${script}" "$*" >&2
    printf "Try '%s --help' for more information.\n" "${script}" >&2
}

# printCoverageModes prints the available coverage modes
# to stdout. This is called in case an invalid mode was
# specified on the command-line.
function printCoverageModes() {
    printf "%s: These coverage modes are available:\n" "${script}"
    printf "  set     test which statements run\n"
    printf "  count   test how often a statement runs\n"
    printf "  atomic  (default) count runs of statement, but\n"
    printf "          correct in multithreaded tests\n"
}

# printHelp outputs a help message with usage instructions
# and documentation for all options to the console.
function printHelp() {
    printf "Usage: %s [option(s)] [--] [package] ...\n" "${script}"
    printf "Generate a coverage profile for the named packages\n"
    printf "and report the coverage results in an output format\n\n"
    printf "The following options are available:\n"
    printf "  -c, --checks=<LIST>   Specify code checks to be run by 'go vet'\n"
    printf "                        before the actual tests. LIST is a comma\n"
    printf "                        separated list of check names. Special values\n"
    printf "                        of LIST are:   all       run all checks\n"
    printf "                                       default   selects all checks that are\n"
    printf "                                                 assumed to be always worth\n"
    printf "                                       off       no checks are done by 'go vet'\n"
    printf "                        The default for LIST is 'default'. Look at\n"
    printf "                        the options documented at 'go tool vet -help'\n"
    printf "                        for a complete list of checks.\n"
    printf "  -m, --coverage-mode=<MODE>\n"
    printf "                        Set the mode for coverage analysis for the\n"
    printf "                        packages being tested. MODE can be one of the\n"
    printf "                        following:     set       test which statements run\n"
    printf "                                       count     test how often a statement runs\n"
    printf "                                       atomic    count runs of statement, but\n"
    printf "                                                 correct in multithreaded tests\n"
    printf "                        The default for MODE is 'atomic'.\n"
    printf "  -p, --coverage-profile=<FILE>\n"
    printf "                        Write the coverage profile generated by 'go test'\n"
    printf "                        to FILE. If --output-directory is supplied the file\n"
    printf "                        is written to the specified output directory.\n"
    printf "  -f, --functions       Generate coverage information for each function\n"
    printf "                        in the applied packages. Overrides --html.\n"
    printf "  -h, --help            Display this help message and exit.\n"
    printf "  -H, --html            Generate a HTML representation of the coverage\n"
    printf "                        profile and open it in the default web browser\n"
    printf "                        unless --output-file is specified in which case\n"
    printf "                        the HTML is written to the specified file.\n"
    printf "                        Overrides --functions.\n"
    printf "  -d, --output-directory=<DIR>\n"
    printf "                        Write the coverage profile and the output file\n"
    printf "                        to the applied directory. DIR must exist and needs\n"
    printf "                        to be a directory.\n"
    printf "  -o, --output-file=<FILE>\n"
    printf "                        Write the outgoing coverage report from 'go tool cover'\n"
    printf "                        to FILE. This can be either a plain text file if\n"
    printf "                        --functions is supplied, or a HTML file if --html\n"
    printf "                        was given. The FILE should not exist yet, otherwise\n"
    printf "                        it is going to be overwritten. The leading directory,\n"
    printf "                        if any, is stripped if --output-directory is given.\n"
    printf "      --preserve-profile\n"
    printf "                        Don't remove the coverage profile after output file\n"
    printf "                        has been generated.\n"
    printf "  -r, --race            Examine the tests and search for race conditions in\n"
    printf "                        parallelized tests or code and report warnings, if any.\n"
    printf "  -v, --verbose         Print information for each executed test such as\n"
    printf "                        test logs and results.\n"
    printf "Mandatory arguments to long options are also mandatory to short options.\n\n"
    printf "By default, the coverage profile is named 'coverage.txt' and is written\n"
    printf "to the directory in which the tests were executed. The --output-directory\n"
    printf "option can change the location, whereas the directory must exist.\n"
    printf "Note that the coverage results are not generated if one of the tests fails.\n\n"
    printf "The default coverage mode is 'atomic' which is a complete analysis\n"
    printf "of the significance of the executed statements. It counts the number\n"
    printf "of executions for each statement and is also correct for tests which run\n"
    printf "on multiple go routines. By default, all checks assumed to be beneficial\n"
    printf "are run before the actual tests.\n\n"
    printf "The option --html is assumed if none of --html or --functions is specified.\n"
    printf "These options override each other. If --output-file is not specified, the\n"
    printf "HTML output will be shown in the default web browser.\n"
}

# assignCoverageMode checks the provided coverage mode
# and set the coverage mode option if the mode is valid.
# If the mode is invalid the script exits with an error.
function assignCoverageMode() {
    local mode_argument="$1"

    case "${mode_argument}" in
        atomic | count | set)
            coverage_mode="${mode_argument}"
            ;;
        *)
            printf "%s: invalid coverage mode: '%s'\n" "${script}" "${mode_argument}" >&2
            printCoverageModes >&2
            exit 3
    esac
}

# assignChecks sets the option that the test step does
# code checks using 'go vet' before executing the actual
# tests. There are three predefined check arguments:
# all, default and off. Other arguments are also valid
# and are passed to the 'go vet' invocation.
function assignChecks() {
    local checks_argument="$1"

    case "${checks_argument}" in
        all)
            checks="all"
            ;;
        default)
            checks=""
            ;;
        off)
            checks="off"
            ;;
        *)
            local IFS=","
            local all_checks=(${checks_argument})
            local go_vet_help="$(go tool vet -help 2>&1)"
            for c in "${all_checks[@]}"; do
                if ! grep -q -- "-\b${c}\b" <<< "${go_vet_help}"; then
                    printError "undefined check: '${c}'" >&2
                    exit 3
                fi
            done

            checks="${checks_argument}"
            ;;
    esac
}

# assignOutputDirectory sets the output directory option
# only if the directory exists and is a directory. If the
# option argument does not exist the scripts exits with
# with an error.
function assignOutputDirectory() {
    local directory_argument="$1"

    if [ -d "${directory_argument}" ]; then
        output_dir="${directory_argument}"
    else
        printError "output directory does not exist: '${directory_argument}'"
        exit 3
    fi
}

# assignOutputFile sets the output file option to the
# specified file. If the file already exists a warning
# is printed to stdout telling that the file will be
# overwritten.
function assignOutputFile() {
    local file_argument="$1"

    if [ -d "${file_argument}" ]; then
        printError "output file is a directory: ${file_argument}"
        exit 3
    elif [ -f "${file_argument}" ]; then
        printf "%s: warning: file '%s' already exists and will be overwritten\n" "${script}" "${file_argument}"
    elif [ -e "${file_argument}" ]; then
        printError "output file exists and is not a regular file: ${file_argument}"
        exit 3
    fi

    output_file="${file_argument}"
}

# Parse the command-line options
while getopts ":c:d:fhHm:o:p:rv-:" option "$@"; do
    case "${option}" in
        c)
            assignChecks "${OPTARG}"
            ;;
        d)
            assignOutputDirectory "${OPTARG}"
            ;;
        f)
            coverage_format="functions"
            ;;
        h)
            printHelp
            exit 0
            ;;
        H)
            coverage_format="html"
            ;;
        m)
            assignCoverageMode "${OPTARG}"
            ;;
        o)
            assignOutputFile "${OPTARG}"
            ;;
        p)
            coverage_profile="${OPTARG}"
            ;;
        r)
            race="true"
            ;;
        v)
            verbose="true"
            ;;
        -)
            option_name="${OPTARG%%=*}"
            option_argument="${OPTARG#*=}"

            long_options="checks coverage-mode coverage-profile functions help html output-directory
                          output-file preserve-profile race verbose"
            long_options_arguments="checks coverage-mode coverage-profile output-directory output-file"

            option_matches=($(compgen -W "${long_options}" -- "${option_name}"))

            if [ "${#option_matches[@]}" -eq 0 ]; then
                printError "unrecognized option: '--${option_name}'" >&2
                exit 1
            elif [ "${#option_matches[@]}" -eq 1 ]; then
                option_name="${option_matches[0]}"

                if compgen -W "${long_options_arguments}" -- "${option_name}" >/dev/null 2>&1 && [[ "${OPTARG}" != *=* ]]; then
                    printError "option requires an argument: '--${option_name}'" >&2
                    exit 2
                elif ! compgen -W "${long_options_arguments}" -- "${option_name}" >/dev/null 2>&1 && [[ "${OPTARG}" == *=* ]]; then
                    printError "option does not allow an argument: '--${option_name}'" >&2
                    exit 2
                fi

                case "${option_name}" in
                    checks)
                        assignChecks "${option_argument}"
                        ;;
                    coverage-mode)
                        assignCoverageMode "${option_argument}"
                        ;;
                    coverage-profile)
                        coverage_profile="${option_argument}"
                        ;;
                    functions)
                        coverage_format="functions"
                        ;;
                    help)
                        printHelp
                        exit 0
                        ;;
                    html)
                        coverage_format="html"
                        ;;
                    output-file)
                        assignOutputFile "${option_argument}"
                        ;;
                    output-directory)
                        assignOutputDirectory "${option_argument}"
                        ;;
                    preserve-profile)
                        preserve_profile="true"
                        ;;
                    race)
                        race="true"
                        ;;
                    verbose)
                        verbose="true"
                        ;;
                esac
            else
                printf "%s: ambiguous option: '--%s'; could be one of:\n" "${script}" "${option_name}" >&2
                printf "  > --%s\n" "${option_matches[@]}" >&2
                printf "Try '%s --help' for more information.\n" "${script}" >&2
                exit 1
            fi
            ;;
        \?)
            printError "invalid option -- ${OPTARG}"
            exit 1
            ;;
        :)
            printError "option requires an argument -- ${OPTARG}"
            exit 2
            ;;
    esac
done

# Shift all the processed options so that only
# non-option parameters remain
shift "$((OPTIND - 1))"

# All non-option parameters are package paths
packages=("$@")
if [ "${#packages[@]}" -eq 0 ]; then
    packages[0]="./..."
else
    for pack in "${packages[@]}"; do
        if [[ "${pack}" =~ /...$ ]]; then
            pack="${pack%/...}"
        fi

        # Check if all packages provided exist
        if ! [ -d "${pack}" ]; then
            printError "package does not exist: '${pack}'"
            exit 1
        fi
    done
fi

# Arrays with options for 'go test' and
# 'go tool cover'
go_test_options=()
go_cover_options=()

# Set the test flag for output directory and strip
# the leading directory of the coverage profile and
# output file paths
if [ -n "${output_dir}" ]; then
    go_test_options+=("-outputdir=${output_dir}")

    coverage_profile="${coverage_profile##*/}"

    if [ -n "${output_file}" ]; then
        output_file="${output_dir}/${output_file##*/}"
    fi
fi

# Set the coverage profile, coverage mode and
# vet options
go_test_options+=("-coverprofile=${coverage_profile}")
go_test_options+=("-covermode=${coverage_mode}")
go_test_options+=("-vet=${checks}")

# Set the race option
if "${race}"; then
    go_test_options+=("-race")
fi

# Set the verbose option
if "${verbose}"; then
    go_test_options+=("-v")
fi

# Set the output file option
if [ -n "${output_file}" ]; then
    go_cover_options+=("-o" "${output_file}")
fi

# Set the correct path to the coverage profile
# if an output directory was specified
if [ -n "${output_dir}" ]; then
    coverage_profile="${output_dir}/${coverage_profile}"
fi

# Set the output format option to either functions
# or HTML
case "${coverage_format}" in
    functions)
        go_cover_options+=("-func=${coverage_profile}")
        ;;
    html)
        go_cover_options+=("-html=${coverage_profile}")
        ;;
esac

printf "%s: Building coverage profile by executing tests in package(s):\n" "${script}"
printf "  - %s\n" "${packages[@]}"

# Execute the tests with coverage and the
# specified options
go test "${go_test_options[@]}" "${packages[@]}"

# Get the exit status (successful test result)
test_status="$?"
exit_status="${test_status}"

# If the tests were successful generate the coverage report
if [ "${test_status}" -eq 0 ] && [ -f "${coverage_profile}" ]; then
    printf "%s: Tests succeeded, generating coverage report\n" "${script}"
    go tool cover "${go_cover_options[@]}"
    exit_status=$?
elif [ "${test_status}" -eq 1 ]; then
    printf "%s: Some of the tests failed, coverage report could not be generated.\n" "${script}"
elif [ "${test_status}" -eq 2 ]; then
    printf "%s: There were build errors in the tests, coverage report could not be generated.\n" "${script}"
fi

# Only delete the coverage profile if the --preserve-report
# option is not set
if ! "${preserve_profile}"; then
    rm -f "${coverage_profile}"
fi

exit "${exit_status}"
