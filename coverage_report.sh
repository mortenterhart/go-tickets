#!/usr/bin/env bash

script="${0##*/}"
root_dir="${0%/*}"

output_dir=""
output_file=""
coverage_profile="${root_dir}/coverage.txt"

checks=""
coverage_mode="atomic"
coverage_format="html"
preserve_report="false"
race="false"
verbose="false"

function printError() {
    printf "%s: %s\n" "${script}" "$*" >&2
    printf "Try '%s --help' for more information.\n" "${script}" >&2
}

function printCovermodes() {
    printf "%s: These coverage modes are available:\n" "${script}"
    printf "  set     test which statements run\n"
    printf "  count   test how often a statement runs\n"
    printf "  atomic  (default) count runs of statement, but\n"
    printf "          correct in multithreaded tests\n"
}

function printHelp() {
    printf "Usage: %s [option(s)] [--] [package] ...\n" "${script}"
    printf "Generate a coverage profile for the named packages\n"
    printf "and report the coverage results in an output format\n\n"
    printf "The following options are available:\n"
    printf "  -c, --checks=<LIST>   Specify code checks to be run by 'go vet'\n"
    printf "                        before the actual tests. LIST is a comma\n"
    printf "                        separated list of check names. Special values\n"
    printf "                        of LIST are:   all       run all checks\n"
    printf "                                       default   selects all checks that are\n"
    printf "                                                 assumed to be always worth\n"
    printf "                                       off       no checks are done by 'go vet'\n"
    printf "                        The default for LIST is 'default'. Look at\n"
    printf "                        the options documented at 'go tool vet -help'\n"
    printf "                        for a complete list of checks.\n"
    printf "  -m, --coverage-mode=<MODE>\n"
    printf "                        Set the mode for coverage analysis for the\n"
    printf "                        packages being tested. MODE can be one of the\n"
    printf "                        following:     set       test which statements run\n"
    printf "                                       count     test how often a statement runs\n"
    printf "                                       atomic    count runs of statement, but\n"
    printf "                                                 correct in multithreaded tests\n"
    printf "                        The default for MODE is 'atomic'.\n"
    printf "  -p, --coverage-profile=<FILE>\n"
    printf "                        Write the coverage profile generated by 'go test'\n"
    printf "                        to FILE. If --output-directory is supplied the file\n"
    printf "                        is written to the specified output directory.\n"
    printf "  -f, --functions       Generate coverage information for each function\n"
    printf "                        in the applied packages. Overrides --html.\n"
    printf "  -h, --help            Display this help message and exit.\n"
    printf "  -H, --html            Generate a HTML representation of the coverage\n"
    printf "                        profile and open it in the default web browser\n"
    printf "                        unless --output-file is specified in which case\n"
    printf "                        the HTML is written to the specified file.\n"
    printf "                        Overrides --functions.\n"
    printf "  -d, --output-directory=<DIR>\n"
    printf "                        Write the coverage profile and the output file\n"
    printf "                        to the applied directory. DIR must exist and needs\n"
    printf "                        to be a directory.\n"
    printf "  -o, --output-file=<FILE>\n"
    printf "                        Write the outgoing coverage report from 'go tool cover'\n"
    printf "                        to FILE. This can be either a plain text file if\n"
    printf "                        --functions is supplied, or a HTML file if --html\n"
    printf "                        was given. The FILE should not exist yet, otherwise\n"
    printf "                        it is going to be overwritten. The leading directory,\n"
    printf "                        if any, is stripped if --output-directory is given.\n"
    printf "      --preserve-report Don't remove the coverage profile after output file\n"
    printf "                        has been generated.\n"
    printf "  -r, --race            Examine the tests and search for race conditions\n"
    printf "                        in parallelized tests and report warnings, if any.\n"
    printf "  -v, --verbose         Print information for each executed test such as\n"
    printf "                        test logs and results.\n"
    printf "Mandatory arguments to long options are also mandatory to short options.\n\n"
    printf "By default, the coverage profile is named 'coverage.txt' and is written\n"
    printf "to the directory in which the tests were executed. The --output-directory\n"
    printf "option can change the location, whereas the directory must exist.\n"
    printf "Note that the coverage results are not generated if one of the tests fails.\n\n"
    printf "The default coverage mode is 'atomic' which is a complete analysis\n"
    printf "of the significance of the executed statements. It counts the number\n"
    printf "of executions for each statement and is also correct for tests which run\n"
    printf "on multiple go routines. By default, all checks assumed to be beneficial\n"
    printf "are run before the actual tests.\n\n"
    printf "The option --html is assumed if none of --html or --functions is specified.\n"
    printf "These options override each other. If --output-file is not specified, the\n"
    printf "HTML output will be shown in the default web browser.\n"
}

function assignCoverageMode() {
    local mode_argument="$1"

    case "${mode_argument}" in
        atomic | count | set)
            coverage_mode="${mode_argument}"
            ;;
        *)
            printf "%s: invalid coverage mode: '%s'\n" "${script}" "${mode_argument}" >&2
            printCovermodes >&2
            exit 3
    esac
}

function assignChecks() {
    local checks_argument="$1"

    case "${checks_argument}" in
        default)
            checks=""
            ;;
        off)
            checks="off"
            ;;
        *)
            checks="${checks_argument}"
            ;;
    esac
}

function assignOutputDirectory() {
    local directory_argument="$1"

    if [ -d "${directory_argument}" ]; then
        output_dir="${directory_argument}"
    else
        printError "output directory does not exist: '${directory_argument}'"
        exit 3
    fi
}

function assignOutputFile() {
    local file_argument="$1"

    if [ -e "${file_argument}" ]; then
        printf "%s: warning: file '%s' already exists and will be overwritten\n" "${script}" "${file_argument}"
    fi

    output_file="${file_argument}"
}

while getopts ":c:d:fhHm:o:p:rv-:" option "$@"; do
    case "${option}" in
        c)
            assignChecks "${OPTARG}"
            ;;
        d)
            assignOutputDirectory "${OPTARG}"
            ;;
        f)
            coverage_format="functions"
            ;;
        h)
            printHelp
            exit 0
            ;;
        H)
            coverage_format="html"
            ;;
        m)
            assignCoverageMode "${OPTARG}"
            ;;
        o)
            assignOutputFile "${OPTARG}"
            ;;
        p)
            coverage_profile="${OPTARG}"
            ;;
        r)
            race="true"
            ;;
        v)
            verbose="true"
            ;;
        -)
            option_name="${OPTARG%%=*}"
            option_argument="${OPTARG#*=}"

            long_options="checks coverage-mode coverage-profile functions help html output-directory
                          output-file preserve-report race verbose"
            long_options_arguments="checks coverage-mode coverage-profile output-directory output-file"

            option_matches=($(compgen -W "${long_options}" -- "${option_name}"))

            if [ "${#option_matches[@]}" -eq 0 ]; then
                printError "unrecognized option: '--${option_name}'" >&2
                exit 1
            elif [ "${#option_matches[@]}" -eq 1 ]; then
                option_name="${option_matches[0]}"

                if compgen -W "${long_options_arguments}" -- "${option_name}" >/dev/null 2>&1 && [[ "${OPTARG}" != *=* ]]; then
                    printError "option requires an argument: '--${option_name}'" >&2
                    exit 2
                elif ! compgen -W "${long_options_arguments}" -- "${option_name}" >/dev/null 2>&1 && [[ "${OPTARG}" == *=* ]]; then
                    printError "option does not allow an argument: '--${option_name}'" >&2
                    exit 2
                fi

                case "${option_name}" in
                    checks)
                        assignChecks "${option_argument}"
                        ;;
                    coverage-mode)
                        assignCoverageMode "${option_argument}"
                        ;;
                    coverage-profile)
                        coverage_profile="${option_argument}"
                        ;;
                    functions)
                        coverage_format="functions"
                        ;;
                    help)
                        printHelp
                        exit 0
                        ;;
                    html)
                        coverage_format="html"
                        ;;
                    output-file)
                        assignOutputFile "${option_argument}"
                        ;;
                    output-directory)
                        assignOutputDirectory "${option_argument}"
                        ;;
                    preserve-report)
                        preserve_report="true"
                        ;;
                    race)
                        race="true"
                        ;;
                    verbose)
                        verbose="true"
                        ;;
                esac
            else
                printf "%s: ambiguous option: '--%s'; could be one of:\n" "${script}" "${option_name}" >&2
                printf "  > --%s\n" "${option_matches[@]}" >&2
                printf "Try '%s --help' for more information.\n" "${script}" >&2
                exit 1
            fi
            ;;
        \?)
            printError "invalid option -- ${OPTARG}"
            exit 1
            ;;
        :)
            printError "option requires an argument -- ${OPTARG}"
            exit 2
            ;;
    esac
done

shift "$((OPTIND - 1))"

packages=("$@")
if [ "${#packages[@]}" -eq 0 ]; then
    packages[0]="./..."
else
    for pack in "${packages[@]}"; do
        if [[ "${pack}" =~ /...$ ]]; then
            pack="${pack%/...}"
        fi

        if ! [ -d "${pack}" ]; then
            printError "package does not exist: '${pack}'"
            exit 1
        fi
    done
fi

go_test_options=()
go_cover_options=()

if [ -n "${output_dir}" ]; then
    go_test_options+=("-outputdir=${output_dir}")

    coverage_profile="${coverage_profile##*/}"

    if [ -n "${output_file}" ]; then
        output_file="${output_dir}/${output_file##*/}"
    fi
fi

go_test_options+=("-coverprofile=${coverage_profile}")
go_test_options+=("-covermode=${coverage_mode}")
go_test_options+=("-vet=${checks}")

if "${race}"; then
    go_test_options+=("-race")
fi

if "${verbose}"; then
    go_test_options+=("-v")
fi

if [ -n "${output_file}" ]; then
    go_cover_options+=("-o" "${output_file}")
fi

if [ -n "${output_dir}" ]; then
    coverage_profile="${output_dir}/${coverage_profile}"
fi

case "${coverage_format}" in
    functions)
        go_cover_options+=("-func=${coverage_profile}")
        ;;
    html)
        go_cover_options+=("-html=${coverage_profile}")
        ;;
esac

printf "%s: Building coverage profile by executing tests in package(s):\n" "${script}"
printf "  - %s\n" "${packages[@]}"

go test "${go_test_options[@]}" "${packages[@]}"

test_successful="$?"
exit_status="${test_successful}"

if [ "${test_successful}" -eq 0 ] && [ -f "${coverage_profile}" ]; then
    printf "%s: Tests succeeded, generating coverage report\n" "${script}"
    go tool cover "${go_cover_options[@]}"
    exit_status=$?

    if ! "${preserve_report}"; then
        rm -f "${coverage_profile}"
    fi
else
    printf "%s: Some of the tests failed, coverage report could not be generated.\n" "${script}"
fi

exit "${exit_status}"
