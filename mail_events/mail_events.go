// Trivial Tickets Ticketsystem
// Copyright (C) 2019 The Contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// Package mail_events provides facilities to create
// standard mail messages for different actions using
// predefined templates.
package mail_events

import (
	"bytes"
	"fmt"
	"html/template"
	"net/url"

	"github.com/mortenterhart/trivial-tickets/globals"
	"github.com/mortenterhart/trivial-tickets/log"
	"github.com/mortenterhart/trivial-tickets/structs"
)

/*
 * Ticketsystem Trivial Tickets
 *
 * Matriculation numbers: 3040018, 6694964, 3478222
 * Lecture:               Programmieren II, INF16B
 * Lecturer:              Herr Prof. Dr. Helmut Neemann
 * Institute:             Duale Hochschule Baden-WÃ¼rttemberg Mosbach
 *
 * ---------------
 *
 * Package mail_events
 * Mail message construction using templating
 */

// Event represents various mailing events occurring on
// different actions to tickets
type Event int

const (
	// NewTicket represents the creation of a new ticket
	NewTicket Event = iota

	// NewAnswer represents the creation of a new answer
	NewAnswer

	// UpdatedTicket represents the update of a ticket
	UpdatedTicket

	// AssignedTicket represents the new assignment to a ticket
	AssignedTicket

	// UnassignedTicket represents the release of a ticket
	UnassignedTicket
)

// String converts a mail event to a string describing
// this event.
func (event Event) String() string {
	switch event {
	case NewTicket:
		return "new ticket"

	case NewAnswer:
		return "new answer"

	case UpdatedTicket:
		return "updated ticket"

	case AssignedTicket:
		return "assigned ticket"

	case UnassignedTicket:
		return "unassigned ticket"
	}

	return "undefined"
}

// templateMap is the type for the map that fills the mail
// template with values.
type templateMap map[string]string

// NewMailBody creates a message to be sent inside a mail body.
// Depending of the mail event (e.g. ticket or answer creation)
// different messages are written to the body and populated with
// information from a given ticket.
func NewMailBody(event Event, ticket structs.Ticket) string {
	mailTemplate := template.New("mail_body")

	// The string was originally built using strings.Builder, however
	// this type was firstly introduced in Go 1.10 and we want a
	// backward compatibility with version 1.7
	var mailBuilder bytes.Buffer
	mailBuilder.WriteString("Dear Customer,\n\n")

	displayLatestAnswer := false

	var eventMessage string
	switch event {
	case NewTicket:
		eventMessage = "Your Ticket '{{.ticketId}}' was created successfully.\n" +
			fmt.Sprintf("If you want to write a new comment to this ticket,\n"+
				"please use the following link: mailto:support@trivial-tickets.com?subject=%s\n",
				url.PathEscape(fmt.Sprintf(`[Ticket "%s"] %s`, ticket.ID, ticket.Subject)))

	case NewAnswer:
		displayLatestAnswer = true
		eventMessage = "the user '{{.newAnswerUser}}' wrote a new comment to your ticket:\n"

	case UpdatedTicket:
		eventMessage = "Your Ticket '{{.ticketId}}' was updated with the following information:\n"

	case AssignedTicket:
		eventMessage = "the editor '{{.assignedUserName}}' works on Your Ticket now:\n"

	case UnassignedTicket:
		eventMessage = "the editor '{{.assignedUserName}}' has released Your Ticket again:\n"

	}

	mailBuilder.WriteString(eventMessage)

	templateString := `
-----------------------------
Customer:   {{.customer}}
Ticket Key: {{.ticketId}}
URL:        {{.url}}
Editor:     {{.assignedUserMail}}
Status:     {{.status}}

Subject: {{.subject}}

{{.message}}

-----------------------------

Kind Regards,
Your Trivial Tickets Team

This message was automatically generated by trivial-tickets.com.
Please do not reply to this e-mail.`

	mailBuilder.WriteString(templateString)

	parsedTemplate, parseErr := mailTemplate.Parse(mailBuilder.String())
	if parseErr != nil {
		log.Error("internal error: could not build mail message from template:", parseErr)
		return ""
	}

	mailBuilder.Reset()

	message, newAnswerUser := getMessage(ticket.Entries, displayLatestAnswer)

	assignedUserMail, assignedUserName := getAssignedUser(ticket.User)

	executeErr := parsedTemplate.Execute(&mailBuilder, templateMap{
		"customer":         ticket.Customer,
		"ticketId":         ticket.ID,
		"url":              fmt.Sprintf("https://localhost:%d/ticket?id=%s", globals.ServerConfig.Port, ticket.ID),
		"assignedUserName": assignedUserName,
		"assignedUserMail": assignedUserMail,
		"status":           ticket.Status.String(),
		"subject":          ticket.Subject,
		"message":          message,
		"newAnswerUser":    newAnswerUser,
	})

	if executeErr != nil {
		log.Error("internal error: could not fill mail template with ticket information:", executeErr)
		return ""
	}

	return mailBuilder.String()
}

// getAssignedUser returns a string for the assigned user to be
// displayed in the mail message. If no user is assigned to the
// ticket it returns a default non-assigned string. The first
// return value is the formatted username along with the user's
// mail address and the second return value is only the name.
func getAssignedUser(user structs.User) (formattedUsername, userMail string) {
	if user == (structs.User{}) {
		return "no editor assigned", "<not assigned>"
	}

	return fmt.Sprintf("%s (%s)", user.Name, user.Mail), user.Name
}

// getMessage returns either the first or the last message written
// to a ticket depending on the parameter displayLatestMessage. The
// username of the user who has written the message is also returned.
// If the ticket does not contain any entries a default message
// indicating that no entry was found is returned.
func getMessage(ticketEntries []structs.Entry, displayLatestMessage bool) (text, username string) {
	if len(ticketEntries) == 0 {
		return "no Entry available", "<no user>"
	}

	if displayLatestMessage {
		latestEntry := ticketEntries[len(ticketEntries)-1]
		return latestEntry.Text, latestEntry.User
	}

	return ticketEntries[0].Text, ticketEntries[0].User
}
